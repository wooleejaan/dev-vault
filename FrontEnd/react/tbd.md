# Trunk Based Development 되돌아보기

부트캠프에서 기존에 프로젝트를 진행할 때, 주로 Github flow를 사용했다.
기능 구현 시나리오가 매우 간단하고 직관적이었으나, 우리의 개발환경에 비춰볼 때 아쉬운 점들이 존재했다.

이를 개선함과 동시에 새로운 워크 플로우를 경험해볼 수 있는 좋은 기회라 생각해 Trunk Based Development(이하 TBD)를 도입해봤다.

### 페어 프로그래밍(또는 몹 프로그래밍)을 하기 좋은 환경

그당시 부트캠프에서 프로젝트를 진행하면, 보통 4–5명이 팀을 이뤄 개발을 했다. 주 3일 오프라인이었지만, 프로젝트 기간에는 다른 공간을 이용해 내내 오프라인 공간에서 다같이 모여 코드를 작성했다. 아침 10시부터 밤 10시까지가 정규 시간이었는데, 사실상 밤 12–1시까지 모여있곤 했다.

같은 공간에서, 같은 프로젝트 주제로 모여 우리는 각자의 코드만 보고 있는 일이 거의 없었다. 서로 모르는 걸 도와주고 하다보니 2인 1조로 혹은 다같이 코드를 작성하는 일이 많았다. 사실상 페어 프로그래밍을 중심으로 하다 보니, 실시간으로 코드 검토가 자연스럽게 이루어졌고 PR이 무의미해지는 경우가 꽤 있었다.

이런 환경이 프로젝트를 진행하기에는 굉장히 좋은 환경이었기에 이를 적극적으로 활용하고 싶었다. 게다가 하나의 프로젝트에 대해 역할을 명확히 구분하고, 내 역할이 아닌 부분은 내가 설명하기 어려운 프로젝트를 부트캠프에서만큼은 하고 싶지 않았다. 기본적으로 github flow는 각각의 feature 브랜치를 분할된 개인이 책임진다. conflict를 최소화하기 위해 역할을 명확히 나누고 각자의 독립적인 코드를 작성하는 것보다는 하나의 팀으로서 코드를 작성하고 책임지는 경험을 하고 싶었다.

### vercel의 강력한 CI/CD

TBD를 도입하려면, 신뢰할 수 있는 CI/CD 환경이 필요하고 이 과정이 자동화되어 있어야 한다. 그렇지 않으면 빈번한 배포 과정이 번거롭기 때문이다. 당시 next.js를 중심으로 프로젝트를 진행했고, 부트캠프에서 vercel 계정을 지원하고 있었다. 자연스럽게 vercel의 강력한 CI/CD를 적극적으로 활용할 수 있는 조건이었기에 TBD를 선택할 수 있었다.

## 장점

### 완전한 CI(Continuous Integration)와 가벼운 Feature

TBD를 도입했다고 해서, feature 브랜치 개념을 없애지는 않았다. 대신 feature 브랜치의 크기를 줄여 서로 같은 공간에서 페어프로그래밍을 하지 않더라도 작은 PR 단위를 생성하도록 의도했다. 덕분에 PR 단위가 줄어 코드리뷰가 훨씬 수월해졌다.

feature flag(toggle)을 도입했다. vercel에서는 환경변수 관리가 굉장히 쉽다. 이를 활용해 심지어 완성된 feature가 아니더라도 feature toggle을 사용해 통합 주기를 짧게 가져갔다. 덕분에 개발 중인 기능의 난이도가 어렵더라도 다양한 코드 리뷰를 통해 아이디어를 주고 받을 수 있게 된다. 개발 난이도에 따라 특정 기능 개발이 오래걸리더라도 병합을 지속적으로 함으로서 완전한 의미의 ci를 목표로한다는 의견을 이해할 수 있었다.

### Confilct에 대한 피로감 저하

하나의 feature 브랜치가 수명이 길어지고 크기가 커지면 커질수록, 마지막에 병합해야 하는 사람은 부담스럽기 마련이다. TBD를 사용하면 pr 단위가 작아진다. pr 단위가 작아지는 만큼 conflict 부담도 줄어든다. 게다가 페어프로그래밍을 적극적으로 할 수 있는 환경이었기에 어떤 부분에서 문제가 생겼는지 바로바로 공유할 수 있기에 더더욱 개발에 부담이 줄어들었다.

## 단점

### feature toggle 관리가 생각보다 어려울지도

feature를 완성하지 않더라도 병합을 할 수 있다. 그리고 toggle을 통해 production에 보여지지 않도록 할 수도 있다. 우리의 프로젝트 규모는 작았고, feature toggle은 굉장히 도움이 됐지만, 규모가 커지고 개발해야 할 기능들이 많아지면 toggle 관리를 어떻게 해야 하지? 라는 막연한 생각이 들기도 했다.

### Commit 관리의 필요성

하나의 트렁크(main 브랜치를 사용했습니다)에 지속적인 병합을 하다보면 커밋들이 중구난방이 되기 쉽다.

기능 개발할 때야 상관없지만, production에 문제가 생겨 백업을 해야 한다면 어떤 기능에서 문제가 생겼는지 찾기 쉬워야 한다. 이때 rebase 혹은 squash merge를 선택하면 그래프가 굉장히 단순해진다.

우리는 Squash Merge 방식을 선택했다. 빈번한 배포 주기 속에서, 하나의 병합 커밋 안에 또 여러 개의 커밋들로 쪼개서 파고 들어 문제를 바라보기 보다는 하나의 기능 단위로만 문제를 정의하고 해결하기를 원했다.

### vercel은 비싸다

vercel이 편리해서 사용했지만 저렴하지 않았다.
