## 인증

http/1.1에서 이용할 수 있는 인증 방식

- basic 인증
- digest 인증
- ssl 클라이언트 인증
- form base 인증
- 통합 windows 인증(kerberos 인증, ntlm 인증)

### basic 인증

http/1.0에 구현된 인증 방식.

- basic 인증이 필요한 리소스에 대한 request인 경우, 서버는 401 Authorization Required 상태 코드와 함꼐 인증 방식(BASIC)과 Request-URI의 보호 공간 식별을 위한 문자열을 WWW-Authenticate 헤더 필드에 포함해서 response
- 401을 받은 클라이언트는 `userId:password` 형식으로 연결하고 Base64 형식으로 인코딩해서 Authorization 헤더 필드에 포함해서 request.
- Authorization 헤더 필드를 포함한 request를 수신한 서버는 인증 정보 확인, 정확하면 Request-URI 리소스 포함하는 response 반환.

Base64는 암호화 방식이 아니므로, 쉽게 복호화할 수 있음.<br>
게다가 1번 BASIC 인증하면 로그아웃 할 수 없음. => 현재 사용 거의x

### DIGEST 인증

BASIC 인증의 약점을 보완해 http/1.1에 소개.

챌린지 response 방식을 사용하므로 BASIC 인증처럼 password를 그대로 보내는 일이 없음.

- 최초에 상대방에게 인증 요구, 상대측에서 받은 챌린지 코드를 사용해서 response 코드 계산. 이 값을 상대에게 송신해서 인증.

#### 인증 수순

- 인증이 필요한 리소스에 대한 request인 경우, 401 상태코드와 함께 챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드(nonce)를 WWW-Authenticate 헤더 필드에 포함(realm, nonce를 반드시 포함)해서 response 반환. (nonce는 401 response 반환할 때마다 생성되는 유일한 문자열로, Base16이거나 16진수로 권장됨)
- 401 수신한 클라이언트는 DIGEST 인증을 위해 필요한 정보를 Authorization 헤더 필드에 포함(username, realm, nonce, uri, response가 반드시 포함. 이중 realm, nonce는 서버에서 받은 것/username은 realm에서 인증 가능한 사용자 이름, uri(digest-uri)는 Request-URI에 있는 것이지만 프록시에 의해 Reqeust-URI가 변경될 수 있으므로 여기에 복사해두는 것/response는 Request-Digest라 불림. password 문자열을 MD5로 계산한 것).
- Authorization 헤더 필드를 포함한 request를 받은 서버는 인증 정보 확인 후, 정확하면 Request-URI의 리소스를 포함하는 response 반환.

DIGEST 인증은 BASIC 인증보단 보안 등급이 높지만, HTTPS의 클라이언트 인증보다는 낮음.

- 패스트워드 도청은 방지하지만, 위장을 방지하는 기술이 없음.

### SSL 클라이언트 인증

HTTPS의 클라이어느 인증서를 이용한 인증 방식. (사전에 등록된 클라이언트에서의 엑세스인지 아닌지 확인)

#### 인증 수순

사전에 클라이언트에 클라이언트 증명서를 배포하고, 설치해둬야 함.

- 인증이 필요한 리소스에 대한 request가 있을 경우, 서버는 클라이언트 증명서를 요구하는 `Certificate Request` 메시지 송신.
- 유저는 송신하는 클라이언트 증명서 선택 후, 클라이언트가 클라이언트 증명서를 `Client Certificate`라는 메시지로 송신
- 서버가 클라이언트 증명서 검증 후, 클라이언트의 공개키 취득 => 그 이후 HTTPS에 의한 암호 개시

#### SSL 클라이언트 인증은 2-Factor 인증에서 사용됨

SSL 클라이언트 인증은 보통 단독으로 사용x. 이후 다룰 form based 인증과 함께 2-factor 인증의 하나로서 사용됨.

- 2-factor 인증은, 패스워드라는 1개 요소 뿐만 아니라 이용자가 가진 다른 정보를 병용해서 인증하는 방법임.

#### SSL 클라이언트 인증은 비용이 듦

클라이언트 증명서는 인증 기관에서 구입하거나, 서버 운영자 자기 자신이 인증 기관을 만들어서 운용하기 위해 비용이 들거나

### Form based 인증

http 프로토콜 사양에 정의된 인증 방식x.<br>
클라이언트가 서버 상의 웹 어플리케이션에 자격정보(Credential)를 송신해 그 자격 정보의 검증 결과에 따라 인증하는 방식임.

대부분 사전에 등록해둔 자격정보인 유저id(임의의 문자열이나 메일 주소 등)와 패스워드를 입력해서 이걸 웹 어플리케이션에 송신, 검증 결과를 토대로 검증 여부 결정. (ex구글)

#### 인증의 대부분은 form based 인증

http가 표준 제공하는 BASIC, DIGEST는 보안 문제로 거의 사용x<br>
보안등급 높은 SSL 클라이언트 인증은 비용 문제로 널리 사용x

SSH, FTP 같은 프로토콜의 경우 서버-클라이언트 간 인증 표준이 존재해 충분하지만,<br>
웹 사이트는 그런 표준은 없기에 각자의 웹 어플리케이션에서 제각각 구현하는 form based 인증을 채용함.

#### 세션 관리와 쿠키에 의한 재현

form based 인증은 표준 사양은 아니지만, 일반적으로 자주 사용하는 방식으로서 `세션 관리`를 위해 `쿠키`를 사용하는 방법을 주로 사용함.

form based 인증 자체는 서버 측 웹 어플리케이션에 의해 클라이언트가 송신해온 userid와 password가 사전에 등록해둔 것과 일치 여부 체크.

하지만 http 자체는 stateless 프로토콜이므로 => 방금 전 인증 성공한 유저라는 걸 프로토콜 레벨에서 유지할 수 없음.

=> 상태 관리가 필요하므로 `세션관리`와 `쿠키`를 사용해서 http에 없는 상태 관리 기능 보충함.

1. 클라이언트가 서버에 유저id, 패스워드 등 자격정보를 포함한 request 송신. 보통은 POST 메서드 사용해서, entity 바디에 자격 정보 저장. 이때 html form 화면 표시와 입력 데이터 송신에는 https 통신을 이용함.
2. 서버는 유저 식별을 위해 세션id 발행. 클라이언트에서 보낸 자격정보 검증해서 인증처리하고, 그 유저의 인증상태를 세션id와 연관지어 서버 측에 기록함. 클라이언트에 보낼 때는 Set-Cookie 헤더 필드에 세션ID를 저장해서 response 반환.

- 세션id는 정리권 번호의 일종으로 다른 유저와 구별하기 위함임. 도난당할 수 있으므로 문자열 어렵게 만들고, 유효기가한 관리 등 필요. XSS 취약성 존재하는 경우를 방지하기 위해 httponly 속성을 부여해둠.

3. 서버측 세션id를 받은 클라이언트는 쿠키로 저장해둠. 다음에 request시 브라우저가 자동으로 쿠키를 송출하므로 세션id가 서버로 전달됨.

form based 인증 방식은 표준화되어 있지는 않음.

- 일반적으로 안전하게 하기 위해 패스워드를 salt라는 부가정보를 사용해서 해시 알고리즘으로 계산한 값 저장. (평문 저장은 위험함)
